#!/usr/bin/python
# 
# This script is used parse the log file generated by the crawler.
# Currently, it will map the ip address to its geo-location. The
# file and its structure might be reorganized in futuren when more
# features are needed.
#
# By Liang Wang @ Dept. Computer Science, University of Helsinki
# 2010.12.01
#


import os, sys
import pickle
import sqlite3 as sqlite
import signal
from binascii import hexlify
import socket
import json

from datetime import datetime

IP_DB_FILE = "./ip.db"
IP_DB_FILE6 = "./ip6.db"
IPv4 = 4
IPv6 = 6

class IPDB(object):
    def __init__(self, db=IP_DB_FILE):
        self.conn = sqlite.connect(db)
        self.cur = self.conn.cursor()
        
        self.conn6 = sqlite.connect(IP_DB_FILE6)
        self.cur6 = self.conn6.cursor()
        pass

    def ip2loc(self, ip):
        i = self.ip2int(ip)
        self.cur.execute("select * from iplocs where ip_start<=? order by ip_start desc limit 1;", (i,))
        for r in self.cur:
            """return {"ip":ip, "country_code":r[1], "country_name":r[2],\
                    "region_code":r[3], "region_name":r[4], "city":r[5],\
                    "zipcode":r[6], "latitude":r[7], "longtitude":r[8],\
                    "metrocodde":r[9]}"""
            return {"ip":ip, "country_code":r[2], "country_name":r[3],\
                    "city":r[4]}

    def ip2int(self, ip):
        a = ip.split(".")
        k = 0
        for i in range(4):
            k = (k<<8) + int(a[i])
        return k
        
    def ipv6_2loc(self, ip):
        i = str(self.ipv6_2int(ip))
        self.cur6.execute("select * from iplocs where ip_start<=? order by ip_start desc limit 1;", (i,))
        for r in self.cur:
            """return {"ip":ip, "country_code":r[1], "country_name":r[2],\
                    "region_code":r[3], "region_name":r[4], "city":r[5],\
                    "zipcode":r[6], "latitude":r[7], "longtitude":r[8],\
                    "metrocodde":r[9]}"""
            return {"ip":ip, "country_code":r[2], "country_name":r[3],\
                    "city":r[4]}

    def ipv6_2int(self, ip):
        return int(hexlify(socket.inet_pton(socket.AF_INET6, ip)), 16)


    def debug(self):
        # Put test code here.
        pass


class Parser(object):
    def __init__(self, dup = "-id"):
        self.ipdb = IPDB()
        self.set_enum(dup)
        pass

    def set_enum(self, m):
        if m == "-id":
            self.enum_func = self.enum_id
        elif m == "-idip":
            self.enum_func = self.enum_idip
        elif m == "-idipport":
            self.enum_func = self.enum_idipport
            
    def get_type(self, host):
        if host.find(':') == -1:
            htype = IPv4
        else:
            htype = IPv6
        return htype

    def citiesInCountry(self, nodes, country_code):
        geo = {"unknown":0}
        err = 0
        for node in self.enum_idip(nodes.values()):
            try:
                if self.get_type(node["host"]) == IPv4:
                    info = self.ipdb.ip2loc(node["host"])
                else:
                    info = self.ipdb.ip6_2loc(node["host"])
                
                if info and info["country_code"] == country_code:
                    if len(info["city"]) == 0:
                        print node["host"]
                    if info["city"] in geo:
                        geo[info["city"]] += 1
                    else:
                        geo[info["city"]] = 1
            except Exception, errMsg:
                print errMsg
                err += 1
        return geo, err

    def geoDistribution(self, nodes, col = "country_name"):
        geo = {"unknown":0}
        city = {"unknown":0}
        err = 0
        count = 0
        start_time = datetime.now()
        for node in self.enum_idip(nodes.values()):
            print count
            count += 1
            try:
                info = self.ipdb.ip2loc(node["host"])
                print info
                if info:
                    if info[col] in geo:
                        geo[info[col]] += 1
                        city[info["city"]] += 1
                    else:
                        geo[info[col]] = 1
                        city[info["city"]] = 1
                else:
                    geo["unknown"] += 1
                    city["unknown"] += 1
            except Exception, errMsg:
                print errMsg
                err += 1
            except KeyboardInterrupt:
                print ''
                break;
            if count == 200:
                break
        
        end_time = datetime.now()
        print end_time-start_time
        return geo, city, err
    
    def enum_id(self, nodes):
        """Each (ID) maps to a distinct node"""
        for n in nodes:
            yield n[0]
        pass

    def enum_idip(self, nodes):
        """Each (ID,ip) maps to a distinct node"""
        for n in nodes:
            s = set()
            for i in n:
                if i["id"] not in s:
                    s.add(i["id"])
                    yield i
        pass

    def enum_idipport(self, nodes):
        """Each (ID,ip,port) maps to a distinct node"""
        for n in nodes:
            for i in n:
                yield i
        pass


def rawdata(f):
    """return the dict to the calling function without any processing."""
    #nodes = pickle.Unpickler(open(f, "r")).load()
    
    f = open('ipv6nodes_reduced.txt', 'rb')
    nodes = json.loads( f.read() )
    f.close()
    return nodes


if __name__=="__main__":
    # The command line is in fix format, sorry for this.
    if len(sys.argv) < 3:
        print "Usage: %s -[id|idip|idipport] logfile" % sys.argv[0]
        sys.exit(1)
    nodes = rawdata(sys.argv[2])
    geo, city, err = Parser(sys.argv[1]).geoDistribution(nodes)
    for k, v in sorted(geo.items(), key=lambda x: -x[1]):
        print k,":",v
    print 'cities:'
    for k, v in sorted(city.items(), key=lambda x: -x[1]):
        print k,":",v
    print err, "errors."
    pass
